# generated by fastapi-codegen:
#   filename:  climb_api.yaml
#   timestamp: 2022-06-01T15:09:47+00:00

from __future__ import annotations
# from distutils.log import debug
from typing import Optional, Any
from dotenv import load_dotenv

from all_ops.client import AuthenticatedClient
from all_ops.models.animal_characteristic_value import AnimalCharacteristicValueModel # noqa
from all_ops.models.bulk_create_animal_request import BulkCreateAnimalRequestModel # noqa
from all_ops.models.bulk_create_birth_request import BulkCreateBirthRequestModel # noqa
from all_ops.models.bulk_create_housing_request import BulkCreateHousingRequestModel # noqa
from all_ops.models.bulk_create_mating_request import BulkCreateMatingRequestModel # noqa
from all_ops.models.bulk_create_sample_request import BulkCreateSampleRequestModel # noqa
from all_ops.models.create_animal_request import CreateAnimalRequestModel
from all_ops.models.create_animal_request_dto import CreateAnimalRequestDtoModel # noqa
from all_ops.models.create_animal_characteristic_instance_request_dto import CreateAnimalCharacteristicInstanceRequestDtoModel # noqa
from all_ops.models.create_animal_characteristic_request_dto import CreateAnimalCharacteristicRequestDtoModel # noqa
from all_ops.models.create_animal_characteristic_request import CreateAnimalCharacteristicRequestModel # noqa
from all_ops.models.create_birth_request import CreateBirthRequestModel
from all_ops.models.create_genotype_request import CreateGenotypeRequestModel
from all_ops.models.create_housing_request import CreateHousingRequestModel
from all_ops.models.create_line_request import CreateLineRequestModel
from all_ops.models.create_line_request_dto import CreateLineRequestDtoModel
from all_ops.models.create_mating_request_dto import CreateMatingRequestDtoModel # noqa
from all_ops.models.create_mating_request import CreateMatingRequestModel
from all_ops.models.create_job_characteristic_instance_request_dto import CreateJobCharacteristicInstanceRequestDtoModel # noqa
from all_ops.models.create_job_characteristic_request_dto import CreateJobCharacteristicRequestDtoModel # noqa
from all_ops.models.create_job_characteristic_request import CreateJobCharacteristicRequestModel # noqa
from all_ops.models.create_sample_characteristic_instance_request_dto import CreateSampleCharacteristicInstanceRequestDtoModel # noqa
from all_ops.models.create_sample_characteristic_request_dto import CreateSampleCharacteristicRequestDtoModel # noqa
from all_ops.models.create_sample_characteristic_request import CreateSampleCharacteristicRequestModel # noqa
from all_ops.models.create_sample_request import CreateSampleRequestModel
from all_ops.models.create_study_characteristic_instance_request_dto import CreateStudyCharacteristicInstanceRequestDtoModel # noqa
from all_ops.models.create_study_characteristic_request_dto import CreateStudyCharacteristicRequestDtoModel # noqa
from all_ops.models.create_study_characteristic_request import CreateStudyCharacteristicRequestModel # noqa
from all_ops.models.genotype_request_dto import GenotypeRequestDtoModel
from all_ops.models.genotype_date_assay_symbol_dto import GenotypeDateAssaySymbolDtoModel # noqa
from all_ops.models.housing import HousingModel
from all_ops.models.housing_location_dto import HousingLocationDtoModel
from all_ops.models.mating_location_dto import MatingLocationDtoModel
from all_ops.models.sample_characteristic_value import SampleCharacteristicValueModel # noqa
from all_ops.models.sample_location_dto import SampleLocationDtoModel
from all_ops.models.source_animal_dto import SourceAnimalDtoModel
from all_ops.models.source_sample_dto import SourceSampleDtoModel
from all_ops.models.update_genotype_request_dto import UpdateGenotypeRequestDtoModel # noqa
from all_ops.types import Response

from all_models import (
    BulkCreateAnimalRequest,
    BulkCreateBirthRequest,
    BulkCreateHousingRequest,
    BulkCreateMatingRequest,
    BulkCreateSampleRequest,
    CreateAnimalCharacteristicInstanceRequestDto,
    CreateAnimalCharacteristicRequest,
    CreateAnimalCharacteristicRequestDto,
    CreateAnimalRequest,
    CreateAnimalRequestDto,
    CreateBirthRequest,
    CreateGenotypeRequest,
    CreateHousingRequest,
    CreateJobCharacteristicInstanceRequestDto,
    CreateJobCharacteristicRequest,
    CreateJobCharacteristicRequestDto,
    CreateLineRequest,
    CreateLineRequestDto,
    CreateMatingRequest,
    CreateSampleCharacteristicInstanceRequestDto,
    CreateSampleCharacteristicRequest,
    CreateSampleCharacteristicRequestDto,
    CreateSampleRequest,
    CreateStudyCharacteristicInstanceRequestDto,
    CreateStudyCharacteristicRequest,
    CreateStudyCharacteristicRequestDto,
    UpdateGenotypeRequestDto,
)

from all_ops.api.animal import (
    get_api_animals,
    get_api_animals_animal_id,
    get_api_animals_history,
    get_api_animals_unique_material_key,
    put_api_animals_unique_material_key,
    put_api_animals_animal_id,
    post_api_animals_bulk_create_animal,
    post_api_animals_create_animal
)

from all_ops.api.birth import (
    get_api_birth,
    post_api_birth_bulk_create_birth,
    post_api_birth_create_birth
)

from all_ops.api.characteristic import (
    get_api_characteristic_animal_characteristic,
    get_api_characteristic_animal_characteristic_instance,
    get_api_characteristic_job_characteristic,
    get_api_characteristic_job_characteristic_instance,
    get_api_characteristic_sample_characteristic,
    get_api_characteristic_sample_characteristic_instance,
    get_api_characteristic_study_characteristic,
    get_api_characteristic_study_characteristic_instance,
    put_api_characteristic_animal_characteristic_instance_key,
    put_api_characteristic_animal_characteristic_key,
    put_api_characteristic_job_characteristic_instance_key,
    put_api_characteristic_job_characteristic_key,
    put_api_characteristic_sample_characteristic_instance_key,
    put_api_characteristic_sample_characteristic_key,
    put_api_characteristic_study_characteristic_instance_key,
    put_api_characteristic_study_characteristic_key,
    post_api_characteristic_study_characteristic,
    post_api_characteristic_animal_characteristic,
    post_api_characteristic_job_characteristic,
    post_api_characteristic_sample_characteristic
)

from all_ops.api.clinical import get_api_clinicals
from all_ops.api.clinical_observation import get_api_clinical_observations
from all_ops.api.cohort import get_api_cohorts
from all_ops.api.construct import get_api_constructs
from all_ops.api.diagnostics import get_api_diagnostics

from all_ops.api.enumeration import (
    get_api_enumeration_enumerationitems,
    get_api_enumeration_enumerations
)

from all_ops.api.genotype import (
    get_api_genotypes,
    put_api_genotypes_genotype_key,
    post_api_genotypes
)

from all_ops.api.housing import (
    get_api_housings,
    post_api_housings_bulk_create_housing,
    post_api_housings_create_housing
)

from all_ops.api.job import get_api_jobs
from all_ops.api.line import (
    get_api_lines,
    post_api_lines,
    put_api_lines_line_key
)

from all_ops.api.location import get_api_locations
from all_ops.api.mating import (
    get_api_matings,
    post_api_matings_bulk_create_mating,
    post_api_matings_create_mating
)

from all_ops.api.protocol import get_api_protocols
from all_ops.api.resource import get_api_resources
from all_ops.api.sample import (
    get_api_samples,
    post_api_samples_bulk_create_sample,
    post_api_samples_create_sample
)

from all_ops.api.study import get_api_studies
from all_ops.api.task_instance import (
    get_api_taskinstances,
    get_api_taskinstances_task_inputs,
    get_api_taskinstances_task_output_sets,
    get_api_taskinstances_task_outputs
)

from all_ops.api.treatment_plan import get_api_treatmentplan
from all_ops.api.vocabulary import (
    get_api_vocabulary_animal_mating_status,
    get_api_vocabulary_animal_status,
    get_api_vocabulary_animal_use,
    get_api_vocabulary_birth_status,
    get_api_vocabulary_breeding_status,
    get_api_vocabulary_container_type,
    get_api_vocabulary_data_type,
    get_api_vocabulary_diet,
    get_api_vocabulary_exit_reason,
    get_api_vocabulary_generation,
    get_api_vocabulary_genotype_assay,
    get_api_vocabulary_genotype_symbol,
    get_api_vocabulary_housing_status,
    get_api_vocabulary_housing_type,
    get_api_vocabulary_iacucprotocol,
    get_api_vocabulary_line_status,
    get_api_vocabulary_line_type,
    get_api_vocabulary_material_origin,
    get_api_vocabulary_material_type,
    get_api_vocabulary_mating_purpose,
    get_api_vocabulary_mating_status,
    get_api_vocabulary_mating_type,
    get_api_vocabulary_physical_marker_type,
    get_api_vocabulary_preservation_method,
    get_api_vocabulary_sample_status,
    get_api_vocabulary_sample_type,
    get_api_vocabulary_sex,
    get_api_vocabulary_taxon,
    get_api_vocabulary_time_unit,
    get_api_vocabulary_unit
)

from all_ops.api.workflow_task import (
    get_api_workflow_tasks,
    get_api_workflow_tasks_inputs,
    get_api_workflow_tasks_outputs
)

from all_ops.api.workgroup_users import get_api_workgroupusers
from all_ops.api.workgroups import (
    get_api_workgroups,
    put_api_workgroups_workgroup_key
)

from fastapi import FastAPI, Query, HTTPException
# from fastapi.encoders import jsonable_encoder
# from fastapi.responses import JSONResponse

import json
import requests
import os

app = FastAPI(
    title='CLIMBex : Extended API',
    description='<h0>Description</h2><p>API for JAX CLIMB...</p><br />',
    contact={'name': 'CLIMBex'},
    version='v1',
)

"""
Initialize Variables
"""
app_client = []
app_client.append(AuthenticatedClient(base_url='http://httpbin.org', token=''))

app_token = []
app_token.append("access_token")

load_dotenv()
os.environ["CLIMB_TOKEN"] = "None"


@app.get('/', response_model=None)
def index() -> str:
    """
    View the current access token
    """
    return "Welcome to CLIMBex!"


@app.get('/api/Token', response_model=None)
def get_new_client(
    page_number: int = Query(None, alias='PageNumber'),
    page_size: int = Query(None, alias='PageSize')
) -> str:
    """
    Get New Token and Client
    """
    str_token = "No Token For You!"

    if page_number + page_size == 2346:

        TOKEN_URL = os.getenv("TOKEN_URL")
        BASE_URL = os.getenv("BASE_URL")
        username = os.getenv("CLIMB_USER")
        userpass = os.getenv("CLIMB_PASS")

        resp = requests.get(f'{TOKEN_URL}', auth=(username, userpass), timeout=55) # noqa

        r = resp.json()
        app_token[0] = r['access_token']
        os.environ["CLIMB_TOKEN"] = app_token[0]

        client = AuthenticatedClient(base_url=f"{BASE_URL}", token=f"{app_token[0]}", verify_ssl=False, timeout=55) # noqa
        app_client[0] = client
        str_token = client.token

    return str_token


@app.get('/api/Diagnostics', response_model=None)
def get_diagnostics() -> Response[Any]:
    """
    Get a paged list of diagnostics
    """
    client = app_client[0]
    response: Response[Any] = get_api_diagnostics.sync_detailed(client=client)
    return response


@app.get('/api/WorkflowTasks', response_model=None)
async def get_workflow_tasks(
    workflow_task_key: Optional[int] = Query(None, alias='WorkflowTaskKey'),
    task_name: Optional[str] = Query(None, alias='TaskName'),
    task_status: Optional[str] = Query(None, alias='TaskStatus'),
    task_name_search_options: Optional[str] = Query(None, alias='TaskNameSearchOptions'), # noqa
    job_key: Optional[int] = Query(None, alias='JobKey'),
    study_key: Optional[int] = Query(None, alias='StudyKey'),
    protocol_key: Optional[int] = Query(None, alias='ProtocolKey'),
    input_key: Optional[int] = Query(None, alias='InputKey'),
    output_key: Optional[int] = Query(None, alias='OutputKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any].parsed:
    """
    Get a paged list of workflowtask
    """
    client = app_client[0]
    response: Response[Any] = await get_api_workflow_tasks.asyncio(
        client=client,
        workflow_task_key=workflow_task_key,
        task_name=task_name,
        task_status=task_status,
        task_name_search_options=task_name_search_options,
        job_key=job_key,
        study_key=study_key,
        protocol_key=protocol_key,
        input_key=input_key,
        output_key=output_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return response


@app.get('/api/WorkflowTasks/inputs', response_model=None)
async def get_workflow_tasks_inputs(
    workflow_task_key: Optional[int] = Query(None, alias='WorkflowTaskKey'),
    input_key: Optional[int] = Query(None, alias='InputKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any].parsed:
    """
    Get a paged list of inputs
    """
    client = app_client[0]
    response: Response[Any] = await get_api_workflow_tasks_inputs.asyncio(
        client=client,
        workflow_task_key=workflow_task_key,
        input_key=input_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return response


@app.get('/api/WorkflowTasks/outputs', response_model=None)
async def get_workflow_tasks_outputs(
    workflow_task_key: Optional[int] = Query(None, alias='WorkflowTaskKey'),
    output_key: Optional[int] = Query(None, alias='OutputKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any].parsed:
    """
    Get a paged list of outputs
    """
    client = app_client[0]
    response: Response[Any] = await get_api_workflow_tasks_outputs.asyncio(
        client=client,
        workflow_task_key=workflow_task_key,
        output_key=output_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return response


@app.get('/api/animals', response_model=Any)
async def get_animals(
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    animal_id: Optional[int] = Query(None, alias='AnimalID'),
    animal_name: Optional[str] = Query(None, alias='AnimalName'),
    animal_name_search_options: Optional[str] = Query(None, alias='AnimalNameSearchOptions'), # noqa
    job_id: Optional[str] = Query(None, alias='JobID'),
    job_key: Optional[int] = Query(None, alias='JobKey'),
    study_key: Optional[int] = Query(None, alias='StudyKey'),
    task_instance_key: Optional[int] = Query(None, alias='TaskInstanceKey'),
    cohort_key: Optional[int] = Query(None, alias='CohortKey'),
    line_key: Optional[int] = Query(None, alias='LineKey'),
    housing_id: Optional[str] = Query(None, alias='HousingID'),
    birth_key: Optional[int] = Query(None, alias='BirthKey'),
    genotype_key: Optional[int] = Query(None, alias='GenotypeKey'),
    clinical_observation_key: Optional[int] = Query(None, alias='ClinicalObservationKey'), # noqa
    animal_history_id: Optional[int] = Query(None, alias='AnimalHistoryID'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of animals
    """
    client = app_client[0]
    response: Response[Any] = await get_api_animals.asyncio_detailed(
        client=client,
        material_key=material_key,
        animal_id=animal_id,
        animal_name=animal_name,
        animal_name_search_options=animal_name_search_options,
        job_id=job_id,
        job_key=job_key,
        study_key=study_key,
        task_instance_key=task_instance_key,
        cohort_key=cohort_key,
        line_key=line_key,
        housing_id=housing_id,
        birth_key=birth_key,
        genotype_key=genotype_key,
        clinical_observation_key=clinical_observation_key,
        animal_history_id=animal_history_id,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.post('/api/animals/bulkCreateAnimal', response_model=Any)
async def post_animals_bulk_create_animal(body: BulkCreateAnimalRequest = None) -> Response[Any]: # noqa
    """
    Bulk Create Animals
    """
    if body.createAnimalRequestDtos is None:
        raise HTTPException(status_code=400, detail='CreateAnimalRequestDtos List is Required') # noqa

    dto_list = []
    for item in body.createAnimalRequestDtos:

        if item.housings is None:
            housing_list = None
        else:
            housing_list = []
            for housing in item.housings:
                housing_model = HousingModel(
                    housing_key=housing.housingKey,
                    date_in=housing.dateIn,
                    date_out=housing.dateOut
                )
                housing_list.append(housing_model)

        if item.animalCharacteristics is None:
            char_list = None
        else:
            char_list = []
            for attrib in item.animalCharacteristics:
                char_model = AnimalCharacteristicValueModel(
                    animal_characteristic_key=attrib.animalCharacteristicKey,
                    characteristic_value=attrib.characteristicValue
                )
                char_list.append(char_model)

        dto_model = CreateAnimalRequestDtoModel(
            line_key=item.lineKey,
            sex_key=item.sexKey,
            generation_key=item.generationKey,
            breeding_status_key=item.breedingStatusKey,
            diet_key=item.dietKey,
            animal_status_key=item.animalStatusKey,
            exit_reason_key=item.exitReasonKey,
            animal_name=item.animalName,
            physical_marker=item.physicalMarker,
            date_born=item.dateBorn,
            date_exit=item.dateExit,
            comments=item.comments,
            date_origin=item.dateOrigin,
            animal_use_key=item.animalUseKey,
            animal_mating_status_key=item.animalMatingStatusKey,
            iacucprotocol_key=item.iacucprotocolKey,
            physical_marker_type_key=item.physicalMarkerTypeKey,
            material_origin_key=item.materialOriginKey,
            external_identifier=item.externalIdentifier,
            microchip_identifier=item.microchipIdentifier,
            job_keys=item.jobKeys,
            cohort_keys=item.cohortKeys,
            housings=housing_list,
            animal_characteristics=char_list
        )
        dto_list.append(dto_model)

    client = app_client[0]
    response: Response[Any] = await post_api_animals_bulk_create_animal.asyncio_detailed( # noqa
        client,
        json_body=BulkCreateAnimalRequestModel(create_animal_request_dtos=dto_list) # noqa
    )
    return response


@app.post('/api/animals/createAnimal', response_model=Any)
async def post_animals_create_animal(body: CreateAnimalRequest = None) -> Response[Any]: # noqa
    """
    Create an animal
    """
    if body.housings is None:
        housing_list = None
    else:
        housing_list = []
        for housing in body.housings:
            housing_model = HousingModel(
                housing_key=housing.housingKey,
                date_in=housing.dateIn,
                date_out=housing.dateOut
            )
            housing_list.append(housing_model)

    if body.animalCharacteristics is None:
        char_list = None
    else:
        char_list = []
        for attrib in body.animalCharacteristics:
            char_model = AnimalCharacteristicValueModel(
                animal_characteristic_key=attrib.animalCharacteristicKey,
                characteristic_value=attrib.characteristicValue
            )
            char_list.append(char_model)

    client = app_client[0]
    response: Response[Any] = await post_api_animals_create_animal.asyncio_detailed( # noqa
        client=client,
        json_body=CreateAnimalRequestModel(
            line_key=body.lineKey,
            sex_key=body.sexKey,
            generation_key=body.generationKey,
            breeding_status_key=body.breedingStatusKey,
            diet_key=body.dietKey,
            animal_status_key=body.animalStatusKey,
            exit_reason_key=body.exitReasonKey,
            animal_name=body.animalName,
            physical_marker=body.physicalMarker,
            date_born=body.dateBorn,
            date_exit=body.dateExit,
            comments=body.comments,
            date_origin=body.dateOrigin,
            animal_use_key=body.animalUseKey,
            animal_mating_status_key=body.animalMatingStatusKey,
            iacucprotocol_key=body.iacucprotocolKey,
            physical_marker_type_key=body.physicalMarkerTypeKey,
            material_origin_key=body.materialOriginKey,
            external_identifier=body.externalIdentifier,
            microchip_identifier=body.microchipIdentifier,
            job_keys=body.jobKeys,
            cohort_keys=body.cohortKeys,
            housings=housing_list,
            animal_characteristics=char_list
        )
    )
    return response


@app.get('/api/animals/history', response_model=Any)
async def get_animals_history(
    animal_history_id: Optional[int] = Query(None, alias='AnimalHistoryID'),
    animal_id: Optional[int] = Query(None, alias='AnimalID'),
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of animal history
    """
    client = app_client[0]
    response: Response[Any] = await get_api_animals_history.asyncio_detailed(
        client=client,
        animal_history_id=animal_history_id,
        animal_id=animal_id,
        material_key=material_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.put('/api/animals/unique/{material_key}', response_model=Any)
async def put_animals_unique_material_key(
    material_key: int,
    body: CreateAnimalRequestDto = None
) -> Response[Any]:
    """
    Update an animal by its materialKey
    """
    if body.lineKey is None:
        raise HTTPException(status_code=400, detail='Line Key is Required')

    if body.housings is None:
        housing_list = None
    else:
        housing_list = []
        for housing in body.housings:
            housing_model = HousingModel(
                housing_key=housing.housingKey,
                date_in=housing.dateIn,
                date_out=housing.dateOut
            )
            housing_list.append(housing_model)

    if body.animalCharacteristics is None:
        char_list = None
    else:
        char_list = []
        for attrib in body.animalCharacteristics:
            char_model = AnimalCharacteristicValueModel(
                animal_characteristic_key=attrib.animalCharacteristicKey,
                characteristic_value=attrib.characteristicValue
            )
            char_list.append(char_model)

    client = app_client[0]
    response: Response[Any] = await put_api_animals_unique_material_key.asyncio_detailed( # noqa
        client=client,
        material_key=material_key,
        json_body=CreateAnimalRequestDtoModel(
            line_key=body.lineKey,
            sex_key=body.sexKey,
            generation_key=body.generationKey,
            breeding_status_key=body.breedingStatusKey,
            diet_key=body.dietKey,
            animal_status_key=body.animalStatusKey,
            exit_reason_key=body.exitReasonKey,
            animal_name=body.animalName,
            physical_marker=body.physicalMarker,
            date_born=body.dateBorn,
            date_exit=body.dateExit,
            comments=body.comments,
            date_origin=body.dateOrigin,
            animal_use_key=body.animalUseKey,
            animal_mating_status_key=body.animalMatingStatusKey,
            iacucprotocol_key=body.iacucprotocolKey,
            physical_marker_type_key=body.physicalMarkerTypeKey,
            material_origin_key=body.materialOriginKey,
            external_identifier=body.externalIdentifier,
            microchip_identifier=body.microchipIdentifier,
            job_keys=body.jobKeys,
            cohort_keys=body.cohortKeys,
            housings=housing_list,
            animal_characteristics=char_list
        )
    )
    return response


@app.get('/api/animals/unique/{material_key}', response_model=None)
async def get_animals_unique_material_key(material_key: int) -> Response[Any]:
    """
    Get an animal by its MaterialKey
    """
    if material_key is None:
        raise HTTPException(status_code=400, detail='Material Key is Required')

    client = app_client[0]
    response: Response[Any] = await get_api_animals_unique_material_key.asyncio_detailed( # noqa
        client=client,
        material_key=material_key
    )
    return json.loads(response.content)


@app.put('/api/animals/{animal_id}', response_model=Any)
async def put_animals_animal_id(
    animal_id: int,
    body: CreateAnimalRequestDto = None
) -> Response[Any]:
    """
    Update an animal by its identifier
    """
    if body.housings is None:
        housing_list = None
    else:
        housing_list = []
        for housing in body.housings:
            housing_model = HousingModel(
                housing_key=housing.housingKey,
                date_in=housing.dateIn,
                date_out=housing.dateOut
            )
            housing_list.append(housing_model)

    if body.animalCharacteristics is None:
        char_list = None
    else:
        char_list = []
        for attrib in body.animalCharacteristics:
            char_model = AnimalCharacteristicValueModel(
                animal_characteristic_key=attrib.animalCharacteristicKey,
                characteristic_value=attrib.characteristicValue
            )
            char_list.append(char_model)

    client = app_client[0]
    response: Response[Any] = await put_api_animals_animal_id.asyncio_detailed(
        client=client,
        animal_id=animal_id,
        json_body=CreateAnimalRequestDtoModel(
            line_key=body.lineKey,
            sex_key=body.sexKey,
            generation_key=body.generationKey,
            breeding_status_key=body.breedingStatusKey,
            diet_key=body.dietKey,
            animal_status_key=body.animalStatusKey,
            exit_reason_key=body.exitReasonKey,
            animal_name=body.animalName,
            physical_marker=body.physicalMarker,
            date_born=body.dateBorn,
            date_exit=body.dateExit,
            comments=body.comments,
            date_origin=body.dateOrigin,
            animal_use_key=body.animalUseKey,
            animal_mating_status_key=body.animalMatingStatusKey,
            iacucprotocol_key=body.iacucprotocolKey,
            physical_marker_type_key=body.physicalMarkerTypeKey,
            material_origin_key=body.materialOriginKey,
            external_identifier=body.externalIdentifier,
            microchip_identifier=body.microchipIdentifier,
            job_keys=body.jobKeys,
            cohort_keys=body.cohortKeys,
            housings=housing_list,
            animal_characteristics=char_list
        )
    )
    return response


@app.get('/api/animals/{animal_id}', response_model=None)
async def get_animals_animal_id(animal_id: int) -> Response[Any]:
    """
    Get an animal by its identifier
    """
    client = app_client[0]
    response: Response[Any] = await get_api_animals_animal_id.asyncio_detailed(
        client=client,
        animal_id=animal_id
    )
    return json.loads(response.content)


@app.get('/api/birth', response_model=None)
async def get_birth(
    birth_key: Optional[int] = Query(None, alias='BirthKey'),
    birth_id: Optional[str] = Query(None, alias='BirthID'),
    mating_id: Optional[str] = Query(None, alias='MatingID'),
    housing_id: Optional[str] = Query(None, alias='HousingID'),
    foster_housing_id: Optional[str] = Query(None, alias='FosterHousingID'),
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    animal_id: Optional[int] = Query(None, alias='AnimalID'),
    task_id: Optional[int] = Query(None, alias='TaskID'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of births
    """
    client = app_client[0]
    response: Response[Any] = await get_api_birth.asyncio_detailed(
        client=client,
        birth_key=birth_key,
        birth_id=birth_id,
        mating_id=mating_id,
        housing_id=housing_id,
        foster_housing_id=foster_housing_id,
        material_key=material_key,
        animal_id=animal_id,
        task_id=task_id,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.post('/api/birth/bulkCreateBirth', response_model=Any)
async def post_birth_bulk_create_birth(body: BulkCreateBirthRequest = None) -> Response[Any]: # noqa
    """
    Bulk Create births
    """
    if body.createBirthRequestDtos is None:
        raise HTTPException(status_code=400, detail='CreateBirthRequestDtos List is Required') # noqa

    birth_list = []
    for birth in body.createBirthRequestDtos:
        birth_model = CreateBirthRequestModel(
            birth_id=birth.birthID,
            mating_id=birth.matingID,
            animal_ids=birth.animalIds,
            birth_status_key=birth.birthStatusKey,
            birth_date=birth.birthDate,
            wean_date=birth.weanDate,
            comments=birth.comments,
            live_born_count=birth.liveBornCount,
            stillborn_count=birth.stillbornCount,
            dead_count=birth.deadCount,
            is_foster=birth.isFoster,
            foster_housing_id=birth.fosterHousingID
        )
        birth_list.append(birth_model)

    client = app_client[0]
    response: Response[Any] = await post_api_birth_bulk_create_birth.asyncio_detailed( # noqa
        client=client,
        json_body=BulkCreateBirthRequestModel(create_birth_request_dtos=birth_list) # noqa
    )
    return response


@app.post('/api/birth/createBirth', response_model=Any)
async def post_birth_create_birth(body: CreateBirthRequest = None) -> Response[Any]: # noqa
    """
    Create a birth
    """
    client = app_client[0]
    response: Response[Any] = await post_api_birth_create_birth.asyncio_detailed( # noqa
        client=client,
        json_body=CreateBirthRequestModel(
            birth_id=body.birthID,
            mating_id=body.matingID,
            animal_ids=body.animalIds,
            birth_status_key=body.birthStatusKey,
            birth_date=body.birthDate,
            wean_date=body.weanDate,
            comments=body.comments,
            live_born_count=body.liveBornCount,
            stillborn_count=body.stillbornCount,
            dead_count=body.deadCount,
            is_foster=body.isFoster,
            foster_housing_id=body.fosterHousingID
        )
    )
    return response


@app.get('/api/characteristic/animalCharacteristic', response_model=None)
async def get_characteristic_animal_characteristic(
    key: Optional[int] = Query(None, alias='Key'),
    taxon_key: Optional[int] = Query(None, alias='TaxonKey'),
    line_key: Optional[int] = Query(None, alias='LineKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of animal characteristics
    """
    client = app_client[0]
    response: Response[Any] = await get_api_characteristic_animal_characteristic.asyncio_detailed( # noqa
        client=client,
        key=key,
        taxon_key=taxon_key,
        line_key=line_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.post('/api/characteristic/animalCharacteristic', response_model=Any)
async def post_characteristic_animal_characteristic(
    body: CreateAnimalCharacteristicRequest = None
) -> Response[Any]:
    """
    Create an animal characteristic
    """
    client = app_client[0]
    response: Response[Any] = await post_api_characteristic_animal_characteristic.asyncio_detailed( # noqa
        client=client,
        json_body=CreateAnimalCharacteristicRequestModel(
            taxon_key=body.taxonKey,
            name=body.name,
            description=body.description,
            data_type_key=body.dataTypeKey,
            enumeration_key=body.enumerationKey,
            is_active=body.isActive,
            minimum_value=body.minimunValue,
            maximum_value=body.maximumValue,
            decimal_places=body.decimalPlaces,
            number_of_rows=body.numberOfRows
        )
    )
    return response


@app.put('/api/characteristic/animalCharacteristic/{key}', response_model=Any)
async def put_characteristic_animal_characteristic_key(
    key: int,
    body: CreateAnimalCharacteristicRequestDto = None
) -> Response[Any]:
    """
    Update an animal characteristic by its AnimalCharacteristicKey
    """
    client = app_client[0]
    response: Response[Any] = await put_api_characteristic_animal_characteristic_key.asyncio_detailed( # noqa
        client=client,
        key=key,
        json_body=CreateAnimalCharacteristicRequestDtoModel(
            taxon_key=body.taxonKey,
            name=body.name,
            description=body.description,
            data_type_key=body.dataTypeKey,
            enumeration_key=body.enumerationKey,
            is_active=body.isActive,
            minimum_value=body.minimunValue,
            maximum_value=body.maximumValue,
            decimal_places=body.decimalPlaces,
            number_of_rows=body.numberOfRows
        )
    )
    return response


@app.get('/api/characteristic/animalCharacteristicInstance', response_model=None) # noqa
async def get_characteristic_animal_characteristic_instance(
    animal_characteristic_instance_key: Optional[int] = Query(None, alias='AnimalCharacteristicInstanceKey'), # noqa
    animal_characteristic_key: Optional[int] = Query(None, alias='AnimalCharacteristicKey'), # noqa
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    line_key: Optional[int] = Query(None, alias='LineKey'),
    taxon_key: Optional[int] = Query(None, alias='TaxonKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of animal's characteristic instances
    """
    client = app_client[0]
    response: Response[Any] = await get_api_characteristic_animal_characteristic_instance.asyncio_detailed( # noqa
        client=client,
        animal_characteristic_instance_key=animal_characteristic_instance_key,
        animal_characteristic_key=animal_characteristic_key,
        material_key=material_key,
        line_key=line_key,
        taxon_key=taxon_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.put('/api/characteristic/animalCharacteristicInstance/{key}', response_model=Any) # noqa
async def put_characteristic_animal_characteristic_instance_key(
    key: int,
    body: CreateAnimalCharacteristicInstanceRequestDto = None
) -> Response[Any]:
    """
    Update an animal characteristic instance by its AnimalCharacteristicInstanceKey # noqa
    """
    client = app_client[0]
    response: Response[Any] = await put_api_characteristic_animal_characteristic_instance_key.asyncio_detailed( # noqa
        client=client,
        key=key,
        json_body=CreateAnimalCharacteristicInstanceRequestDtoModel(
            animal_characteristic_key=body.animalCharacteristicKey,
            material_key=body.materialKey,
            characteristic_value=body.characteristicValue
        )
    )
    return response


@app.get('/api/characteristic/jobCharacteristic', response_model=None)
async def get_characteristic_job_characteristic(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of job characteristics
    """
    client = app_client[0]
    response: Response[Any] = await get_api_characteristic_job_characteristic.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.post('/api/characteristic/jobCharacteristic', response_model=Any)
async def post_characteristic_job_characteristic(
    body: CreateJobCharacteristicRequest = None
) -> Response[Any]:
    """
    Create a job characteristic
    """
    client = app_client[0]
    response: Response[Any] = await post_api_characteristic_job_characteristic.asyncio_detailed( # noqa
        client=client,
        json_body=CreateJobCharacteristicRequestModel(
            job_type_key=body.jobTypeKey,
            name=body.name,
            description=body.description,
            data_type_key=body.dataTypeKey,
            enumeration_key=body.enumerationKey,
            is_active=body.isActive,
            minimum_value=body.minimunValue,
            maximum_value=body.maximumValue,
            decimal_places=body.decimalPlaces,
            number_of_rows=body.numberOfRows
        )
    )
    return response


@app.put('/api/characteristic/jobCharacteristic/{key}', response_model=Any)
async def put_characteristic_job_characteristic_key(
    key: int,
    body: CreateJobCharacteristicRequestDto = None
) -> Response[Any]:
    """
    Update a job characteristic by its JobCharacteristicKey
    """
    client = app_client[0]
    response: Response[Any] = await put_api_characteristic_job_characteristic_key.asyncio_detailed( # noqa
        client=client,
        key=key,
        json_body=CreateJobCharacteristicRequestDtoModel(
            job_type_key=body.jobTypeKey,
            name=body.name,
            description=body.description,
            data_type_key=body.dataTypeKey,
            enumeration_key=body.enumerationKey,
            is_active=body.isActive,
            minimum_value=body.minimunValue,
            maximum_value=body.maximumValue,
            decimal_places=body.decimalPlaces,
            number_of_rows=body.numberOfRows
        )
    )
    return response


@app.get('/api/characteristic/jobCharacteristicInstance', response_model=None)
async def get_characteristic_job_characteristic_instance(
    job_characteristic_instance_key: Optional[int] = Query(None, alias='JobCharacteristicInstanceKey'), # noqa
    job_characteristic_key: Optional[int] = Query(None, alias='JobCharacteristicKey'), # noqa
    job_key: Optional[int] = Query(None, alias='JobKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of job's characteristic instances
    """
    client = app_client[0]
    response: Response[Any] = await get_api_characteristic_job_characteristic_instance.asyncio_detailed( # noqa
        client=client,
        job_characteristic_instance_key=job_characteristic_instance_key,
        job_characteristic_key=job_characteristic_key,
        job_key=job_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.put('/api/characteristic/jobCharacteristicInstance/{key}', response_model=Any) # noqa
async def put_characteristic_job_characteristic_instance_key(
    key: int,
    body: CreateJobCharacteristicInstanceRequestDto = None
) -> Response[Any]:
    """
    Update a job characteristic instance by its JobCharacteristicInstanceKey
    """
    if body is None:
        raise HTTPException(status_code=400, detail='Job Characteristic Dto is Required') # noqa

    client = app_client[0]
    response: Response[Any] = await put_api_characteristic_job_characteristic_instance_key.asyncio_detailed( # noqa
        client=client,
        key=key,
        json_body=CreateJobCharacteristicInstanceRequestDtoModel(
            job_characteristic_key=body.jobCharacteristicKey,
            job_key=body.jobKey,
            characteristic_value=body.characteristicValue
        )
    )
    return response


@app.get('/api/characteristic/sampleCharacteristic', response_model=None)
async def get_characteristic_sample_characteristic(
    key: Optional[int] = Query(None, alias='Key'),
    sample_type_key: Optional[int] = Query(None, alias='SampleTypeKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of sample characteristics
    """
    client = app_client[0]
    response: Response[Any] = await get_api_characteristic_sample_characteristic.asyncio_detailed( # noqa
        client=client,
        key=key,
        sample_type_key=sample_type_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.post('/api/characteristic/sampleCharacteristic', response_model=Any)
async def post_characteristic_sample_characteristic(
    body: CreateSampleCharacteristicRequest = None
) -> Response[Any]:
    """
    Create a sample characteristic
    """
    client = app_client[0]
    response: Response[Any] = await post_api_characteristic_sample_characteristic.asyncio_detailed( # noqa
        client=client,
        json_body=CreateSampleCharacteristicRequestModel(
            sample_type_key=body.sampleTypeKey,
            name=body.name,
            description=body.description,
            data_type_key=body.dataTypeKey,
            enumeration_key=body.enumerationKey,
            is_active=body.isActive,
            minimum_value=body.minimunValue,
            maximum_value=body.maximumValue,
            decimal_places=body.decimalPlaces,
            number_of_rows=body.numberOfRows
        )
    )
    return response


@app.put('/api/characteristic/sampleCharacteristic/{key}', response_model=Any)
async def put_characteristic_sample_characteristic_key(
    key: int,
    body: CreateSampleCharacteristicRequestDto = None
) -> Response[Any]:
    """
    Update a sample characteristic by its SampleCharacteristicKey
    """
    client = app_client[0]
    response: Response[Any] = await put_api_characteristic_sample_characteristic_key.asyncio_detailed( # noqa
        client=client,
        key=key,
        json_body=CreateSampleCharacteristicRequestDtoModel(
            sample_type_key=body.sampleTypeKey,
            name=body.name,
            description=body.description,
            data_type_key=body.dataTypeKey,
            enumeration_key=body.enumerationKey,
            is_active=body.isActive,
            minimum_value=body.minimunValue,
            maximum_value=body.maximumValue,
            decimal_places=body.decimalPlaces,
            number_of_rows=body.numberOfRows
        )
    )
    return response


@app.get('/api/characteristic/sampleCharacteristicInstance', response_model=None) # noqa
async def get_characteristic_sample_characteristic_instance(
    sample_characteristic_instance_key: Optional[int] = Query(None, alias='SampleCharacteristicInstanceKey'), # noqa
    sample_characteristic_key: Optional[int] = Query(None, alias='SampleCharacteristicKey'), # noqa
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of sample's characteristic instances
    """
    client = app_client[0]
    response: Response[Any] = await get_api_characteristic_sample_characteristic_instance.asyncio_detailed( # noqa
        client=client,
        sample_characteristic_instance_key=sample_characteristic_instance_key,
        sample_characteristic_key=sample_characteristic_key,
        material_key=material_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.put('/api/characteristic/sampleCharacteristicInstance/{key}', response_model=Any) # noqa
async def put_characteristic_sample_characteristic_instance_key(
    key: int,
    body: CreateSampleCharacteristicInstanceRequestDto = None
) -> Response[Any]:
    """
    Update a sample characteristic instance by its SampleCharacteristicInstanceKey # noqa
    """
    if body.sampleCharacteristicKey is None:
        raise HTTPException(status_code=400, detail='SampleCharacteristicKey is required') # noqa
    if body.materialKey is None:
        raise HTTPException(status_code=400, detail='Missing material key')

    client = app_client[0]
    response: Response[Any] = await put_api_characteristic_sample_characteristic_instance_key.asyncio_detailed( # noqa
        client=client,
        key=key,
        json_body=CreateSampleCharacteristicInstanceRequestDtoModel(
            sample_characteristic_key=body.sampleCharacteristicKey,
            material_key=body.materialKey,
            characteristic_value=body.characteristicValue
        )
    )
    return response


@app.get('/api/characteristic/studyCharacteristic', response_model=None)
async def get_characteristic_study_characteristic(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of study characteristics
    """
    client = app_client[0]
    response: Response[Any] = await get_api_characteristic_study_characteristic.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.post('/api/characteristic/studyCharacteristic', response_model=Any)
async def post_characteristic_study_characteristic(
    body: CreateStudyCharacteristicRequest = None
) -> Response[Any]:
    """
    Create a study characteristic
    """
    client = app_client[0]
    response: Response[Any] = await post_api_characteristic_study_characteristic.asyncio_detailed( # noqa
        client,
        json_body=CreateStudyCharacteristicRequestModel(
            study_type_key=body.studyTypeKey,
            name=body.name,
            description=body.description,
            data_type_key=body.dataTypeKey,
            enumeration_key=body.enumerationKey,
            is_active=body.isActive,
            minimum_value=body.minimunValue,
            maximum_value=body.maximumValue,
            decimal_places=body.decimalPlaces,
            number_of_rows=body.numberOfRows
        )
    )
    return response


@app.put('/api/characteristic/studyCharacteristic/{key}', response_model=Any)
async def put_characteristic_study_characteristic_key(
    key: int,
    body: CreateStudyCharacteristicRequestDto = None
) -> Response[Any]:
    """
    Update a study characteristic by its StudyCharacteristicKey
    """
    client = app_client[0]
    response: Response[Any] = await put_api_characteristic_study_characteristic_key.asyncio_detailed( # noqa
        client=client,
        key=key,
        json_body=CreateStudyCharacteristicRequestDtoModel(
            study_type_key=body.studyTypeKey,
            name=body.name,
            description=body.description,
            data_type_key=body.dataTypeKey,
            enumeration_key=body.enumerationKey,
            is_active=body.isActive,
            minimum_value=body.minimunValue,
            maximum_value=body.maximumValue,
            decimal_places=body.decimalPlaces,
            number_of_rows=body.numberOfRows
        )
    )
    return response


@app.get('/api/characteristic/studyCharacteristicInstance', response_model=None) # noqa
async def get_characteristic_study_characteristic_instance(
    study_characteristic_instance_key: Optional[int] = Query(None, alias='StudyCharacteristicInstanceKey'), # noqa
    study_characteristic_key: Optional[int] = Query(None, alias='StudyCharacteristicKey'), # noqa
    study_key: Optional[int] = Query(None, alias='StudyKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of study's characteristic instances
    """
    client = app_client[0]
    response: Response[Any] = await get_api_characteristic_study_characteristic_instance.asyncio_detailed( # noqa
        client=client,
        study_characteristic_instance_key=study_characteristic_instance_key,
        study_characteristic_key=study_characteristic_key,
        study_key=study_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.put('/api/characteristic/studyCharacteristicInstance/{key}', response_model=Any) # noqa
async def put_characteristic_study_characteristic_instance_key(
    key: int,
    body: CreateStudyCharacteristicInstanceRequestDto = None
) -> Response[Any]:
    """
    Update a study characteristic instance by its StudyCharacteristicInstanceKey # noqa
    """
    client = app_client[0]
    response: Response[Any] = await put_api_characteristic_study_characteristic_instance_key.asyncio_detailed( # noqa
        client=client,
        key=key,
        json_body=CreateStudyCharacteristicInstanceRequestDtoModel(
            study_characteristic_key=body.studyCharacteristicKey,
            study_key=body.studyKey,
            characteristic_value=body.characteristicValue
        )
    )
    return response


@app.get('/api/clinicalObservations', response_model=None)
async def get_clinical_observations(
    clinical_observation_key: Optional[int] = Query(None, alias='ClinicalObservationKey'), # noqa
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of clinical observations
    """
    client = app_client[0]
    response: Response[Any] = await get_api_clinical_observations.asyncio_detailed( # noqa
        client=client,
        clinical_observation_key=clinical_observation_key,
        material_key=material_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/clinicals', response_model=None)
async def get_clinicals(
    materialkey: Optional[int] = Query(None, alias='Materialkey'),
    animal_id: Optional[int] = Query(None, alias='AnimalId'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of clinicals
    """
    client = app_client[0]
    response: Response[Any] = await get_api_clinicals.asyncio_detailed(
        client=client,
        materialkey=materialkey,
        animal_id=animal_id,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/cohorts', response_model=None)
async def get_cohorts(
    cohort_key: Optional[int] = Query(None, alias='CohortKey'),
    cohort_name: Optional[str] = Query(None, alias='CohortName'),
    animal_id: Optional[int] = Query(None, alias='AnimalID'),
    task_instance_key: Optional[int] = Query(None, alias='TaskInstanceKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of cohorts
    """
    client = app_client[0]
    response: Response[Any] = await get_api_cohorts.asyncio_detailed(
        client=client,
        cohort_key=cohort_key,
        animal_id=animal_id,
        task_instance_key=task_instance_key,
        cohort_name=cohort_name,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/constructs', response_model=None)
async def get_constructs(
    construct_key: Optional[int] = Query(None, alias='ConstructKey'),
    construct_id: Optional[str] = Query(None, alias='ConstructID'),
    name: Optional[str] = Query(None, alias='Name'),
    line_key: Optional[int] = Query(None, alias='LineKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of constructs
    """
    client = app_client[0]
    response: Response[Any] = await get_api_constructs.asyncio_detailed(
        client=client,
        construct_key=construct_key,
        construct_id=construct_id,
        name=name,
        line_key=line_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/enumeration/enumerationitems', response_model=None)
async def get_enumeration_enumerationitems(
    enumeration_key: Optional[int] = Query(None, alias='EnumerationKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of enumeration items by its enumeration key
    """
    client = app_client[0]
    response: Response[Any] = await get_api_enumeration_enumerationitems.asyncio_detailed( # noqa
        client=client,
        enumeration_key=enumeration_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/enumeration/enumerations', response_model=None)
async def get_enumeration_enumerations(
    enumeration_key: Optional[int] = Query(None, alias='EnumerationKey'),
    name: Optional[str] = Query(None, alias='Name'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of enumerations
    """
    client = app_client[0]
    response: Response[Any] = await get_api_enumeration_enumerations.asyncio_detailed( # noqa
        client=client,
        enumeration_key=enumeration_key,
        name=name,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/genotypes', response_model=None)
async def get_genotypes(
    genotype_key: Optional[int] = Query(None, alias='GenotypeKey'),
    animal_id: Optional[int] = Query(None, alias='AnimalID'),
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of genotypes
    """
    client = app_client[0]
    response: Response[Any] = await get_api_genotypes.asyncio_detailed(
        client=client,
        genotype_key=genotype_key,
        animal_id=animal_id,
        material_key=material_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.post('/api/genotypes', response_model=Any)
async def post_genotypes(body: CreateGenotypeRequest = None) -> Response[Any]:
    """
    Create one or more genotypes
    """
    if body.genotypeRequestDtos is None:
        raise HTTPException(status_code=400, detail='CreateGenotypeRequestDtos List is Required') # noqa

    geno_list = []
    for geno in body.genotypeRequestDtos:
        if geno.genotypes is None:
            assym_list = None
        else:
            assym_list = []

            for assym in geno.genotypes:
                assym_model = GenotypeDateAssaySymbolDtoModel(
                    date=assym.date,
                    genotype_assay_key=assym.genotypeAssayKey,
                    genotype_symbol_key=assym.genotypeSymbolKey
                )
                assym_list.append(assym_model)

            geno_model = GenotypeRequestDtoModel(
                animal_id=geno.animalID,
                plate_key=geno.plateKey,
                genotypes=assym_list
            )
            geno_list.append(geno_model)

    client = app_client[0]
    response: Response[Any] = await post_api_genotypes.asyncio_detailed(
        client=client,
        json_body=CreateGenotypeRequestModel(genotype_request_dtos=geno_list)
        )
    return response


@app.put('/api/genotypes/{genotype_key}', response_model=Any)
async def put_genotypes_genotype_key(
    genotype_key: int,
    body: UpdateGenotypeRequestDto = None,
) -> Response[Any]:
    """
    Update a genotype by its genotypeKey
    """
    client = app_client[0]
    response: Response[Any] = await put_api_genotypes_genotype_key.asyncio_detailed( # noqa
        client=client,
        genotype_key=genotype_key,
        json_body=UpdateGenotypeRequestDtoModel(
            animal_id=body.animalID,
            plate_key=body.plateKey,
            date=body.date,
            genotype_assay_key=body.genotypeAssayKey,
            genotype_symbol_key=body.genotypeSymbolKey
        )
    )
    return response


@app.get('/api/housings', response_model=None)
async def get_housings(
    housing_id: Optional[str] = Query(None, alias='HousingID'),
    animal_id: Optional[int] = Query(None, alias='AnimalID'),
    location_id: Optional[str] = Query(None, alias='LocationID'),
    task_id: Optional[int] = Query(None, alias='TaskID'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of housings
    """
    client = app_client[0]
    response: Response[Any] = await get_api_housings.asyncio_detailed(
        client=client,
        housing_id=housing_id,
        animal_id=animal_id,
        location_id=location_id,
        task_id=task_id,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.post('/api/housings/bulkCreateHousing', response_model=Any)
async def post_housings_bulk_create_housing(body: BulkCreateHousingRequest = None) -> Response[Any]: # noqa
    """
    Bulk Create housings
    """
    if body.createHousingRequestDtos is None:
        raise HTTPException(status_code=400, detail='CreateHousingRequestDtos List is Required') # noqa

    housing_list = []
    for housing in body.createHousingRequestDtos:
        if housing.locations is None:
            location_list = None
        else:
            location_list = []
            for loc in housing.locations:
                loc_model = HousingLocationDtoModel(
                    location_key=loc.locationKey,
                    date_in=loc.dateIn,
                    date_out=loc.dateOut
                )
                location_list.append(loc_model)

        housing_model = CreateHousingRequestModel(
            material_pool_id=housing.materialPoolID,
            housing_type_key=housing.housingTypeKey,
            housing_status_key=housing.housingStatusKey,
            date=housing.date,
            owner=housing.owner,
            container_type_key=housing.containerTypeKey,
            comments=housing.comments,
            animal_ids=housing.animalIds,
            locations=location_list
        )
        housing_list.append(housing_model)

    client = app_client[0]
    response: Response[Any] = await post_api_housings_bulk_create_housing.asyncio_detailed( # noqa
        client=client,
        json_body=BulkCreateHousingRequestModel(create_housing_request_dtos=housing_list) # noqa
    )
    return response


@app.post('/api/housings/createHousing', response_model=Any)
async def post_housings_create_housing(body: CreateHousingRequest = None) -> Response[Any]: # noqa
    """
    Create a housing
    """
    if body.locations is None:
        location_list = None
    else:
        location_list = []
        for locations_item_data in body.locations:
            loc_model = HousingLocationDtoModel(
                location_key=locations_item_data.locationKey,
                date_in=locations_item_data.dateIn,
                date_out=locations_item_data.dateOut
            )
            location_list.append(loc_model)

    client = app_client[0]
    response: Response[Any] = await post_api_housings_create_housing.asyncio_detailed( # noqa
        client=client,
        json_body=CreateHousingRequestModel(
            material_pool_id=body.materialPoolID,
            housing_type_key=body.housingTypeKey,
            housing_status_key=body.housingStatusKey,
            date=body.date,
            owner=body.owner,
            container_type_key=body.containerTypeKey,
            comments=body.comments,
            animal_ids=body.animalIds,
            locations=location_list
        )
    )
    return response


@app.get('/api/jobs', response_model=None)
async def get_jobs(
    job_key: Optional[int] = Query(None, alias='JobKey'),
    job_id: Optional[str] = Query(None, alias='JobID'),
    study_key: Optional[int] = Query(None, alias='StudyKey'),
    task_instance_key: Optional[int] = Query(None, alias='TaskInstanceKey'),
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    animal_id: Optional[int] = Query(None, alias='AnimalID'),
    sample_id: Optional[int] = Query(None, alias='SampleID'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of jobs (experiments 2.0)
    """
    client = app_client[0]
    response: Response[Any] = await get_api_jobs.asyncio_detailed(
        client=client,
        job_key=job_key,
        job_id=job_id,
        study_key=study_key,
        task_instance_key=task_instance_key,
        material_key=material_key,
        animal_id=animal_id,
        sample_id=sample_id,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/lines', response_model=None)
async def get_lines(
    line_key: Optional[int] = Query(None, alias='LineKey'),
    name: Optional[str] = Query(None, alias='Name'),
    short_name: Optional[str] = Query(None, alias='ShortName'),
    active: Optional[bool] = Query(None, alias='Active'),
    line_type_key: Optional[int] = Query(None, alias='LineTypeKey'),
    genotype_assays_key: Optional[int] = Query(None, alias='GenotypeAssaysKey'), # noqa
    technician: Optional[str] = Query(None, alias='Technician'),
    default_location_key: Optional[int] = Query(None, alias='DefaultLocationKey'), # noqa
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of lines
    """
    client = app_client[0]
    response: Response[Any] = await get_api_lines.asyncio_detailed(
        client=client,
        line_key=line_key,
        name=name,
        short_name=short_name,
        active=active,
        line_type_key=line_type_key,
        genotype_assays_key=genotype_assays_key,
        technician=technician,
        default_location_key=default_location_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.post('/api/lines', response_model=Any)
async def post_lines(body: CreateLineRequest = None) -> Response[Any]:
    """
    Create a line
    """
    client = app_client[0]
    response: Response[Any] = await post_api_lines.asyncio_detailed(
        client=client,
        json_body=CreateLineRequestModel(
            is_active=body.isActive,
            line_name=body.lineName,
            short_name=body.shortName,
            stock=body.stock,
            line_type_key=body.lineTypeKey,
            line_status_key=body.lineStatusKey,
            taxon_key=body.taxonKey,
            construct_key=body.constructKey,
            genotype_assay_keys=body.genotypeAssayKeys,  # List[int]
            technician=body.technician,
            parent_line_key=body.parentLine,
            background_line=body.backgroundLine,
            breeding_strategy=body.breedingStrategy,
            development=body.development,
            external_link=body.externalLink,
            references=body.references,
            comments=body.comments,
            default_location_key=body.defaultLocationKey
        )
    )
    return response


@app.put('/api/lines/{line_key}', response_model=Any)
async def put_lines_line_key(
    line_key: int,
    body: CreateLineRequestDto = None
) -> Response[Any]:
    """
    Update a line by its LineKey
    """
    client = app_client[0]
    response: Response[Any] = await put_api_lines_line_key.asyncio_detailed(
        client=client,
        line_key=line_key,
        json_body=CreateLineRequestDtoModel(
            is_active=body.isActive,
            line_name=body.lineName,
            short_name=body.shortName,
            stock=body.stock,
            line_type_key=body.lineTypeKey,
            line_status_key=body.lineStatusKey,
            taxon_key=body.taxonKey,
            construct_key=body.constructKey,
            genotype_assay_keys=body.genotypeAssayKeys,  # List[int]
            technician=body.technician,
            parent_line_key=body.parentLine,
            background_line=body.backgroundLine,
            breeding_strategy=body.breedingStrategy,
            development=body.development,
            external_link=body.externalLink,
            references=body.references,
            comments=body.comments,
            default_location_key=body.defaultLocationKey
        )
    )
    return response


@app.get('/api/locations', response_model=None)
async def get_locations(
    location_key: Optional[int] = Query(None, alias='LocationKey'),
    location_name: Optional[str] = Query(None, alias='LocationName'),
    parent_location_key: Optional[int] = Query(None, alias='ParentLocationKey'), # noqa
    parent_location_name: Optional[str] = Query(None, alias='ParentLocationName'), # noqa
    location_type_key: Optional[int] = Query(None, alias='LocationTypeKey'),
    material_type_key: Optional[int] = Query(None, alias='MaterialTypeKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of locations
    """
    client = app_client[0]
    response: Response[Any] = await get_api_locations.asyncio_detailed(
        client=client,
        location_key=location_key,
        location_name=location_name,
        parent_location_key=parent_location_key,
        parent_location_name=parent_location_name,
        location_type_key=location_type_key,
        material_type_key=material_type_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/matings', response_model=None)
async def get_matings(
    mating_id: Optional[str] = Query(None, alias='MatingID'),
    housing_id: Optional[str] = Query(None, alias='HousingID'),
    animal_id: Optional[int] = Query(None, alias='AnimalID'),
    sample_id: Optional[int] = Query(None, alias='SampleID'),
    task_id: Optional[int] = Query(None, alias='TaskID'),
    birth_id: Optional[str] = Query(None, alias='BirthID'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of matings
    """
    client = app_client[0]
    response: Response[Any] = await get_api_matings.asyncio_detailed(
        client=client,
        mating_id=mating_id,
        housing_id=housing_id,
        animal_id=animal_id,
        sample_id=sample_id,
        task_id=task_id,
        birth_id=birth_id,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.post('/api/matings/bulkCreateMating', response_model=Any)
async def post_matings_bulk_create_mating(body: BulkCreateMatingRequest = None) -> Response[Any]: # noqa
    """
    Bulk Create matings
    """
    if body.createMatingRequestDtos is None:
        raise HTTPException(status_code=400, detail='CreateMatingRequestDtos List is Required') # noqa

    mating_list = []
    for mating in body.createMatingRequestDtos:
        if mating.locations is None:
            location_list = None
        else:
            location_list = []
            for loc in mating.locations:
                loc_model = MatingLocationDtoModel(
                    location_key=loc.locationKey,
                    date_in=loc.dateIn,
                    date_out=loc.dateOut
                )
                location_list.append(loc_model)

        mating_model = CreateMatingRequestDtoModel(
            mating_id=mating.matingID,
            housing_id=mating.housingID,
            mating_status_key=mating.matingStatusKey,
            line_key=mating.lineKey,
            mating_date=mating.matingDate,
            mating_type_key=mating.matingTypeKey,
            mating_purpose_key=mating.matingPurposeKey,
            offspring_generation_key=mating.offspringGenerationKey,
            container_type_key=mating.containerTypeKey,
            animal_ids=mating.animalIds,
            job_keys=mating.jobKeys,
            locations=location_list
        )
        mating_list.append(mating_model)

    client = app_client[0]
    response: Response[Any] = await post_api_matings_bulk_create_mating.asyncio_detailed( # noqa
        client=client,
        json_body=BulkCreateMatingRequestModel(create_mating_request_dtos=mating_list) # noqa
    )
    return response


@app.post('/api/matings/createMating', response_model=Any)
async def post_matings_create_mating(body: CreateMatingRequest = None) -> Response[Any]: # noqa
    """
    Create a mating
    """
    if body.locations is None:
        location_list = None
    else:
        location_list = []
        for loc in body.locations:
            loc_model = MatingLocationDtoModel(
                location_key=loc.locationKey,
                date_in=loc.dateIn,
                date_out=loc.dateOut
            )
            location_list.append(loc_model)

    client = app_client[0]
    response: Response[Any] = await post_api_matings_create_mating.asyncio_detailed( # noqa
        client=client,
        json_body=CreateMatingRequestModel(
            mating_id=body.matingID,
            housing_id=body.housingID,
            mating_status_key=body.matingStatusKey,
            line_key=body.lineKey,
            mating_date=body.matingDate,
            mating_type_key=body.matingTypeKey,
            mating_purpose_key=body.matingPurposeKey,
            offspring_generation_key=body.offspringGenerationKey,
            container_type_key=body.containerTypeKey,
            animal_ids=body.animalIds,
            job_keys=body.jobKeys,
            locations=location_list
        )
    )
    return response


@app.get('/api/protocols', response_model=None)
async def get_protocols(
    protocol_key: Optional[int] = Query(None, alias='ProtocolKey'),
    is_active: Optional[bool] = Query(None, alias='IsActive'),
    line_key: Optional[int] = Query(None, alias='LineKey'),
    task_key: Optional[int] = Query(None, alias='TaskKey'),
    owner_id: Optional[str] = Query(None, alias='OwnerID'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of protocols
    """
    client = app_client[0]
    response: Response[Any] = await get_api_protocols.asyncio_detailed(
        client=client,
        protocol_key=protocol_key,
        is_active=is_active,
        line_key=line_key,
        task_key=task_key,
        owner_id=owner_id,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/resources', response_model=None)
async def get_resources(
    resource_key: Optional[int] = Query(None, alias='ResourceKey'),
    resource_name: Optional[str] = Query(None, alias='ResourceName'),
    resource_email: Optional[str] = Query(None, alias='ResourceEmail'),
    resource_type_key: Optional[int] = Query(None, alias='ResourceTypeKey'),
    user_id: Optional[str] = Query(None, alias='UserId'),
    has_user_id: Optional[bool] = Query(None, alias='HasUserId'),
    is_active: Optional[bool] = Query(None, alias='IsActive'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of resources
    """
    client = app_client[0]
    response: Response[Any] = await get_api_resources.asyncio_detailed(
        client=client,
        resource_key=resource_key,
        resource_name=resource_name,
        resource_email=resource_email,
        resource_type_key=resource_type_key,
        user_id=user_id,
        has_user_id=has_user_id,
        is_active=is_active,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/samples', response_model=None)
async def get_samples(
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    sample_name: Optional[str] = Query(None, alias='SampleName'),
    sample_id: Optional[int] = Query(None, alias='SampleID'),
    job_key: Optional[int] = Query(None, alias='JobKey'),
    job_id: Optional[str] = Query(None, alias='JobID'),
    study_key: Optional[int] = Query(None, alias='StudyKey'),
    task_instance_key: Optional[int] = Query(None, alias='TaskInstanceKey'),
    sample_status_key: Optional[int] = Query(None, alias='SampleStatusKey'),
    source_material_key: Optional[int] = Query(None, alias='SourceMaterialKey'), # noqa
    harvest_start_date: Optional[str] = Query(None, alias='HarvestStartDate'),
    harvest_end_date: Optional[str] = Query(None, alias='HarvestEndDate'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of samples
    """
    client = app_client[0]
    response: Response[Any] = await get_api_samples.asyncio_detailed(
        client=client,
        material_key=material_key,
        sample_name=sample_name,
        sample_id=sample_id,
        job_key=job_key,
        job_id=job_id,
        study_key=study_key,
        task_instance_key=task_instance_key,
        sample_status_key=sample_status_key,
        source_material_key=source_material_key,
        harvest_start_date=harvest_start_date,
        harvest_end_date=harvest_end_date,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.post('/api/samples/bulkCreateSample', response_model=Any)
async def post_samples_bulk_create_sample(body: BulkCreateSampleRequest = None) -> Response[Any]: # noqa
    """
    Bulk Create samples
    """
    if body.createSampleRequestDtos is None:
        raise HTTPException(status_code=400, detail='CreateSampleRequestDtos List is Required') # noqa

    for dto in body.createSampleRequestDtos:
        dto_list = []
        if dto.sourceAnimals is None:
            animal_list = None
        else:
            animal_list = []
            for animal in dto.sourceAnimals:
                animal_model = SourceAnimalDtoModel(
                    material_key=animal.materialKey,
                    animal_status_key=animal.animalStatusKey
                )
                animal_list.append(animal_model)

        if dto.sourceSamples is None:
            sample_list = None
        else:
            sample_list = []
            for sample in dto.sourceSamples:
                sample_model = SourceSampleDtoModel(
                    material_key=sample.materialKey,
                    sample_status_key=sample.sampleStatusKey
                )
                sample_list.append(sample_model)

        if dto.locations is None:
            location_list = None
        else:
            location_list = []
            for location in dto.locations:
                loc_model = SampleLocationDtoModel(
                    location_key=location.locationKey,
                    date_in=location.dateIn,
                    date_out=location.dateOut,
                    created_by=location.createdBy,
                    date_created=location.dateCreated,
                    modified_by=location.modifiedBy,
                    date_modified=location.dateModified
                )
                location_list.append(loc_model)

        if dto.sampleCharacteristics is None:
            char_list = None
        else:
            char_list = []
            for char in dto.sampleCharacteristics:
                char_model = SampleCharacteristicValueModel(
                    sample_characteristic_key=char.sampleCharacteristicKey,
                    characteristic_value=char.characteristicValue
                )
                char_list.append(char_model)

        dto_model = CreateSampleRequestModel(
            name=dto.name,
            source_animals=animal_list,
            source_samples=sample_list,
            locations=location_list,
            sample_type_key=dto.sampleTypeKey,
            time_unit_value=dto.timeUnitValue,
            time_unit_key=dto.timeUnitKey,
            date_harvest=dto.dateHarvest,
            preservation_method_key=dto.preservationMethodKey,
            expiration_date=dto.expirationDate,
            line_key=dto.lineKey,
            sample_status_key=dto.sampleStatusKey,
            material_origin_key=dto.materialOriginKey,
            microchip_id=dto.microchipId,
            external_id=dto.externalId,
            container_type_key=dto.containerTypeKey,
            measurement=dto.measurement,
            unit_key=dto.unitKey,
            job_keys=dto.jobKeys,
            construct_keys=dto.constructKeys,
            description=dto.description,
            order_key=dto.orderKey,
            lot_key=dto.lotKey,
            sample_characteristics=char_list
        )
        dto_list.append(dto_model)

    client = app_client[0]
    response: Response[Any] = await post_api_samples_bulk_create_sample.asyncio_detailed( # noqa
        client=client,
        json_body=BulkCreateSampleRequestModel(create_sample_request_dtos=dto_list) # noqa
    )
    return response


@app.post('/api/samples/createSample', response_model=Any)
async def post_samples_create_sample(body: CreateSampleRequest = None) -> Response[Any]: # noqa
    """
    Create a sample
    """
    if body.sourceAnimals is None:
        animal_list = None
    else:
        animal_list = []
        for animal in body.sourceAnimals:
            animal_model = SourceAnimalDtoModel(
                material_key=animal.materialKey,
                animal_status_key=animal.animalStatusKey
            )
            animal_list.append(animal_model)

    if body.sourceSamples is None:
        sample_list = None
    else:
        sample_list = []
        for sample in body.sourceSamples:
            sample_model = SourceSampleDtoModel(
                material_key=sample.materialKey,
                sample_status_key=sample.sampleStatusKey
            )
            sample_list.append(sample_model)

    if body.locations is None:
        location_list = None
    else:
        location_list = []
        for location in body.locations:
            loc_model = SampleLocationDtoModel(
                location_key=location.locationKey,
                date_in=location.dateIn,
                date_out=location.dateOut,
                created_by=location.createdBy,
                date_created=location.dateCreated,
                modified_by=location.modifiedBy,
                date_modified=location.dateModified
            )
            location_list.append(loc_model)

    if body.sampleCharacteristics is None:
        char_list = None
    else:
        char_list = []
        for char in body.sampleCharacteristics:
            char_model = SampleCharacteristicValueModel(
                sample_characteristic_key=char.sampleCharacteristicKey,
                characteristic_value=char.characteristicValue
            )
            char_list.append(char_model)

    client = app_client[0]
    response: Response[Any] = await post_api_samples_create_sample.asyncio_detailed( # noqa
        client=client,
        json_body=CreateSampleRequestModel(
            name=body.name,
            source_animals=animal_list,
            source_samples=sample_list,
            locations=location_list,
            sample_type_key=body.sampleTypeKey,
            time_unit_value=body.timeUnitValue,
            time_unit_key=body.timeUnitKey,
            date_harvest=body.dateHarvest,
            preservation_method_key=body.preservationMethodKey,
            expiration_date=body.expirationDate,
            line_key=body.lineKey,
            sample_status_key=body.sampleStatusKey,
            material_origin_key=body.materialOriginKey,
            microchip_id=body.microchipId,
            external_id=body.externalId,
            container_type_key=body.containerTypeKey,
            measurement=body.measurement,
            unit_key=body.unitKey,
            job_keys=body.jobKeys,
            construct_keys=body.constructKeys,
            description=body.description,
            order_key=body.orderKey,
            lot_key=body.lotKey,
            sample_characteristics=char_list
        )
    )
    return response


@app.get('/api/studies', response_model=None)
async def get_studies(
    study_key: Optional[int] = Query(None, alias='StudyKey'),
    type_key: Optional[int] = Query(None, alias='TypeKey'),
    status_key: Optional[int] = Query(None, alias='StatusKey'),
    line_key: Optional[int] = Query(None, alias='LineKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of studies
    """
    client = app_client[0]
    response: Response[Any] = await get_api_studies.asyncio_detailed(
        client=client,
        study_key=study_key,
        type_key=type_key,
        status_key=status_key,
        line_key=line_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/taskinstances', response_model=None)
async def get_taskinstances(
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    job_key: Optional[int] = Query(None, alias='JobKey'),
    task_instance_key: Optional[int] = Query(None, alias='TaskInstanceKey'),
    workflow_task_key: Optional[int] = Query(None, alias='WorkflowTaskKey'),
    workflow_task_name: Optional[str] = Query(None, alias='WorkflowTaskName'),
    completed_start_date: Optional[str] = Query(None, alias='CompletedStartDate'), # noqa
    completed_end_date: Optional[str] = Query(None, alias='CompletedEndDate'),
    due_start_date: Optional[str] = Query(None, alias='DueStartDate'),
    due_end_date: Optional[str] = Query(None, alias='DueEndDate'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of task instances
    """
    client = app_client[0]
    response: Response[Any] = await get_api_taskinstances.asyncio_detailed(
        client=client,
        material_key=material_key,
        job_key=job_key,
        task_instance_key=task_instance_key,
        workflow_task_key=workflow_task_key,
        workflow_task_name=workflow_task_name,
        completed_start_date=completed_start_date,
        completed_end_date=completed_end_date,
        due_start_date=due_start_date,
        due_end_date=due_end_date,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/taskinstances/taskInputs', response_model=None)
async def get_taskinstances_task_inputs(
    task_input_key: Optional[int] = Query(None, alias='TaskInputKey'),
    task_instance_key: Optional[int] = Query(None, alias='TaskInstanceKey'),
    input_key: Optional[int] = Query(None, alias='InputKey'),
    input_name: Optional[str] = Query(None, alias='InputName'),
    workflow_task_key: Optional[int] = Query(None, alias='WorkflowTaskKey'),
    workflow_task_name: Optional[str] = Query(None, alias='WorkflowTaskName'),
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of taskInputs
    """
    client = app_client[0]
    response: Response[Any] = await get_api_taskinstances_task_inputs.asyncio_detailed( # noqa
        client=client,
        task_input_key=task_input_key,
        task_instance_key=task_instance_key,
        input_key=input_key,
        input_name=input_name,
        workflow_task_key=workflow_task_key,
        workflow_task_name=workflow_task_name,
        material_key=material_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/taskinstances/taskOutputSets', response_model=None)
async def get_taskinstances_task_output_sets(
    task_output_set_key: Optional[int] = Query(None, alias='TaskOutputSetKey'),
    task_instance_key: Optional[int] = Query(None, alias='TaskInstanceKey'),
    task_alias: Optional[str] = Query(None, alias='TaskAlias'),
    workflow_task_key: Optional[int] = Query(None, alias='WorkflowTaskKey'),
    workflow_task_name: Optional[str] = Query(None, alias='WorkflowTaskName'),
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of taskOutputSets
    """
    client = app_client[0]
    response: Response[Any] = await get_api_taskinstances_task_output_sets.asyncio_detailed( # noqa
        client=client,
        task_output_set_key=task_output_set_key,
        task_instance_key=task_instance_key,
        task_alias=task_alias,
        workflow_task_key=workflow_task_key,
        workflow_task_name=workflow_task_name,
        material_key=material_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/taskinstances/taskOutputs', response_model=None)
async def get_taskinstances_task_outputs(
    task_output_key: Optional[int] = Query(None, alias='TaskOutputKey'),
    task_output_set_key: Optional[int] = Query(None, alias='TaskOutputSetKey'),
    task_instance_key: Optional[int] = Query(None, alias='TaskInstanceKey'),
    output_key: Optional[int] = Query(None, alias='OutputKey'),
    output_name: Optional[str] = Query(None, alias='OutputName'),
    task_alias: Optional[str] = Query(None, alias='TaskAlias'),
    workflow_task_key: Optional[int] = Query(None, alias='WorkflowTaskKey'),
    workflow_task_name: Optional[str] = Query(None, alias='WorkflowTaskName'),
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of taskOutputs
    """
    client = app_client[0]
    response: Response[Any] = await get_api_taskinstances_task_outputs.asyncio_detailed( # noqa
        client=client,
        task_output_key=task_output_key,
        task_output_set_key=task_output_set_key,
        task_instance_key=task_instance_key,
        output_key=output_key,
        output_name=output_name,
        task_alias=task_alias,
        workflow_task_key=workflow_task_key,
        workflow_task_name=workflow_task_name,
        material_key=material_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/treatmentplan', response_model=None)
async def get_treatmentplan(
    material_key: Optional[int] = Query(None, alias='MaterialKey'),
    task_animal_healt_record_key: Optional[int] = Query(None, alias='TaskAnimalHealtRecord_key'), # noqa
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of treatment plans
    """
    client = app_client[0]
    response: Response[Any] = await get_api_treatmentplan.asyncio_detailed(
        client=client,
        material_key=material_key,
        task_animal_healt_record_key=task_animal_healt_record_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)
    pass


@app.get('/api/vocabulary/animalMatingStatus', response_model=None)
async def get_vocabulary_animal_mating_status(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of AnimalMatingStatus
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_animal_mating_status.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/animalStatus', response_model=None)
async def get_vocabulary_animal_status(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of AnimalStatus
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_animal_status.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/animalUse', response_model=None)
async def get_vocabulary_animal_use(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of AnimalUse
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_animal_use.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/birthStatus', response_model=None)
async def get_vocabulary_birth_status(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of BirthStatus
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_birth_status.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/breedingStatus', response_model=None)
async def get_vocabulary_breeding_status(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of BreedingStatus
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_breeding_status.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/containerType', response_model=None)
async def get_vocabulary_container_type(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of ContainerType
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_container_type.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/dataType', response_model=None)
async def get_vocabulary_data_type(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of DataType
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_data_type.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/diet', response_model=None)
async def get_vocabulary_diet(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of Diet
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_diet.asyncio_detailed(
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/exitReason', response_model=None)
async def get_vocabulary_exit_reason(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of ExitReason
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_exit_reason.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/generation', response_model=None)
async def get_vocabulary_generation(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of Generation
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_generation.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/genotypeAssay', response_model=None)
async def get_vocabulary_genotype_assay(
    key: Optional[int] = Query(None, alias='Key'),
    line_key: Optional[int] = Query(None, alias='LineKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of GenotypeAssay
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_genotype_assay.asyncio_detailed( # noqa
        client=client,
        key=key,
        line_key=line_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/genotypeSymbol', response_model=None)
async def get_vocabulary_genotype_symbol(
    key: Optional[int] = Query(None, alias='Key'),
    genotype_assay_key: Optional[int] = Query(None, alias='GenotypeAssayKey'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of GenotypeSymbol
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_genotype_symbol.asyncio_detailed( # noqa
        client=client,
        key=key,
        genotype_assay_key=genotype_assay_key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/housingStatus', response_model=None)
async def get_vocabulary_housing_status(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of HousingStatus
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_housing_status.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/housingType', response_model=None)
async def get_vocabulary_housing_type(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of HousingType
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_housing_type.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/iacucprotocol', response_model=None)
async def get_vocabulary_iacucprotocol(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of Iacucprotocol
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_iacucprotocol.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/lineStatus', response_model=None)
async def get_vocabulary_line_status(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of LineStatus
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_line_status.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/lineType', response_model=None)
async def get_vocabulary_line_type(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of LineType
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_line_type.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/materialOrigin', response_model=None)
async def get_vocabulary_material_origin(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of MaterialOrigin
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_material_origin.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/materialType', response_model=None)
async def get_vocabulary_material_type(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of MaterialType
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_material_type.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/matingPurpose', response_model=None)
async def get_vocabulary_mating_purpose(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of MatingPurpose
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_mating_purpose.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/matingStatus', response_model=None)
async def get_vocabulary_mating_status(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of MatingStatus
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_mating_status.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/matingType', response_model=None)
async def get_vocabulary_mating_type(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of MatingType
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_mating_type.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/physicalMarkerType', response_model=None)
async def get_vocabulary_physical_marker_type(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of PhysicalMarkerType
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_physical_marker_type.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/preservationMethod', response_model=None)
async def get_vocabulary_preservation_method(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of PreservationMethod
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_preservation_method.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/sampleStatus', response_model=None)
async def get_vocabulary_sample_status(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of SampleStatus
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_sample_status.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/sampleType', response_model=None)
async def get_vocabulary_sample_type(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of SampleType
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_sample_type.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/sex', response_model=None)
async def get_vocabulary_sex(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of Sex
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_sex.asyncio_detailed(
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/taxon', response_model=None)
async def get_vocabulary_taxon(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of taxon
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_taxon.asyncio_detailed(
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/timeUnit', response_model=None)
async def get_vocabulary_time_unit(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of TimeUnit
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_time_unit.asyncio_detailed( # noqa
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/vocabulary/unit', response_model=None)
async def get_vocabulary_unit(
    key: Optional[int] = Query(None, alias='Key'),
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of Unit
    """
    client = app_client[0]
    response: Response[Any] = await get_api_vocabulary_unit.asyncio_detailed(
        client=client,
        key=key,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.get('/api/workgroups', response_model=None)
async def get_workgroups(
    workgroup_key: Optional[int] = Query(None, alias='WorkgroupKey'),
    workgroup_name: Optional[str] = Query(None, alias='WorkgroupName'),
    is_current: Optional[bool] = Query(None, alias='IsCurrent'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of your workgroups
    """
    client = app_client[0]
    response: Response[Any] = await get_api_workgroups.asyncio_detailed(
        client=client,
        workgroup_key=workgroup_key,
        workgroup_name=workgroup_name,
        is_current=is_current,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


@app.put('/api/workgroups/{workgroup_key}', response_model=Any)
async def put_workgroups_workgroup_key(
    workgroup_key: int
) -> Response[Any]:
    """
    Update your current workgroup by workgroupKey
    """
    client = app_client[0]
    response: Response[Any] = await put_api_workgroups_workgroup_key.asyncio_detailed( # noqa
        client=client,
        workgroup_key=workgroup_key
    )
    return response


@app.get('/api/workgroupusers', response_model=None)
async def get_workgroupusers(
    workgroup_user_key: Optional[int] = Query(None, alias='WorkgroupUserKey'),
    user_key: Optional[str] = Query(None, alias='UserKey'),
    user_first_name: Optional[str] = Query(None, alias='UserFirstName'),
    user_last_name: Optional[str] = Query(None, alias='UserLastName'),
    user_name: Optional[str] = Query(None, alias='UserName'),
    role_key: Optional[int] = Query(None, alias='RoleKey'),
    is_study_administrator: Optional[bool] = Query(None, alias='IsStudyAdministrator'), # noqa
    created_by: Optional[str] = Query(None, alias='CreatedBy'),
    created_start_date: Optional[str] = Query(None, alias='CreatedStartDate'),
    created_end_date: Optional[str] = Query(None, alias='CreatedEndDate'),
    modified_by: Optional[str] = Query(None, alias='ModifiedBy'),
    modified_start_date: Optional[str] = Query(None, alias='ModifiedStartDate'), # noqa
    modified_end_date: Optional[str] = Query(None, alias='ModifiedEndDate'),
    page_number: Optional[int] = Query(None, alias='PageNumber'),
    page_size: Optional[int] = Query(None, alias='PageSize')
) -> Response[Any]:
    """
    Get a paged list of workgroupusers
    """
    client = app_client[0]
    response: Response[Any] = await get_api_workgroupusers.asyncio_detailed(
        client=client,
        workgroup_user_key=workgroup_user_key,
        user_key=user_key,
        user_first_name=user_first_name,
        user_last_name=user_last_name,
        user_name=user_name,
        role_key=role_key,
        is_study_administrator=is_study_administrator,
        created_by=created_by,
        created_start_date=created_start_date,
        created_end_date=created_end_date,
        modified_by=modified_by,
        modified_start_date=modified_start_date,
        modified_end_date=modified_end_date,
        page_number=page_number,
        page_size=page_size
    )
    return json.loads(response.content)


if __name__ == "__main__":
    app.debug = False
